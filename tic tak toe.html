<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tic-Tac-Toe with AI</title>
  <style>
    :root {
      --primary-color: #4a90e2;
      --board-bg: #f0f0f0;
      --cell-size: 100px;
      --font-main: 'Helvetica Neue', Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: var(--font-main);
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
    }

    h1 {
      margin-top: 2rem;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    .controls {
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .controls label {
      font-weight: bold;
    }

    select {
      padding: 0.25rem;
      font-size: 1rem;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(3, var(--cell-size));
      grid-template-rows: repeat(3, var(--cell-size));
      gap: 5px;
      background-color: var(--board-bg);
      padding: 5px;
      border: 2px solid var(--primary-color);
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background-color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      transition: background-color 0.2s;
      user-select: none;
    }

    .cell:hover {
      background-color: #eaeaea;
    }

    .cell.X {
      color: #e74c3c; /* Red-ish for X */
    }
    .cell.O {
      color: #2ecc71; /* Green-ish for O */
    }

    .info {
      margin-top: 1.5rem;
      font-size: 1.1rem;
      text-align: center;
      min-height: 1.5rem;
    }

    .reset-button {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .reset-button:hover {
      background-color: #3a74b7;
    }

    /* Responsive tweak */
    @media (max-width: 480px) {
      :root {
        --cell-size: 80px;
      }
      .controls {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>

  <h1>Tic-Tac-Toe</h1>

  <div class="controls">
    <label for="difficulty">AI Difficulty:</label>
    <select id="difficulty">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
    </select>
  </div>

  <div class="board" id="board">
    <!-- Cells will be injected by JS or you can manually place them -->
  </div>

  <div class="info" id="info"></div>

  <button class="reset-button" id="resetBtn">Reset Game</button>

  <script>
    /************************************************************
     * GLOBAL VARIABLES / STATE
     ************************************************************/
    const boardEl = document.getElementById('board');
    const infoEl = document.getElementById('info');
    const resetBtn = document.getElementById('resetBtn');
    const difficultySelector = document.getElementById('difficulty');

    // ' ' = empty, 'X', or 'O'
    let boardState = Array(9).fill(' ');
    // Current player: 'X' or 'O'
    let currentPlayer = 'X';
    // Track game status
    let gameOver = false;

    /************************************************************
     * INIT
     ************************************************************/
    createBoard();

    // Events
    resetBtn.addEventListener('click', resetGame);
    difficultySelector.addEventListener('change', resetGame);

    /************************************************************
     * FUNCTIONS
     ************************************************************/

    // Creates the 3x3 grid
    function createBoard() {
      boardEl.innerHTML = '';
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.setAttribute('data-index', i);
        cell.addEventListener('click', onCellClick);
        boardEl.appendChild(cell);
      }
      updateBoardUI();
    }

    // Called when a player clicks a cell
    function onCellClick(e) {
      if (gameOver) return; // ignore clicks if game is over

      const index = e.target.getAttribute('data-index');
      // If cell is empty, make a move
      if (boardState[index] === ' ') {
        boardState[index] = currentPlayer;
        updateBoardUI();

        // Check if the game ends (win or tie)
        if (checkWin(currentPlayer)) {
          infoEl.textContent = `Player ${currentPlayer} wins!`;
          gameOver = true;
          return;
        } else if (isBoardFull()) {
          infoEl.textContent = `It's a tie!`;
          gameOver = true;
          return;
        }

        // Switch to the other player if not over
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';

        // If the next player is 'O', let AI move
        if (currentPlayer === 'O' && !gameOver) {
          setTimeout(() => aiMove(), 300);
        }
      }
    }

    // AI makes a move based on the selected difficulty
    function aiMove() {
      const diff = difficultySelector.value;

      let bestMove;
      if (diff === 'easy') {
        bestMove = getRandomMove();
      } else if (diff === 'medium') {
        bestMove = getMediumMove();
      } else {
        // Hard: minimax
        bestMove = getBestMoveMinimax('O').index;
      }

      if (bestMove != null && boardState[bestMove] === ' ') {
        boardState[bestMove] = 'O';
        updateBoardUI();

        if (checkWin('O')) {
          infoEl.textContent = `Player O (AI) wins!`;
          gameOver = true;
          return;
        } else if (isBoardFull()) {
          infoEl.textContent = `It's a tie!`;
          gameOver = true;
          return;
        }

        currentPlayer = 'X';
      }
    }

    /************************************************************
     * AI Helper Functions
     ************************************************************/

    // 1. Easy - picks a random empty cell
    function getRandomMove() {
      const emptyIndices = boardState
        .map((val, idx) => (val === ' ' ? idx : null))
        .filter(idx => idx != null);

      if (emptyIndices.length === 0) return null;
      const randIndex = Math.floor(Math.random() * emptyIndices.length);
      return emptyIndices[randIndex];
    }

    // 2. Medium - 50% random, 50% “check block or winning move”
    function getMediumMove() {
      // 50% chance to do random
      if (Math.random() < 0.5) {
        return getRandomMove();
      } else {
        // Attempt to find a winning move, or block opponent
        let move = findWinningMove('O');
        if (move != null) return move;
        move = findWinningMove('X');
        if (move != null) return move;

        // else random if no obvious move
        return getRandomMove();
      }
    }

    // A helper to see if there's a winning or blocking move
    function findWinningMove(player) {
      const emptyIndices = boardState
        .map((val, idx) => (val === ' ' ? idx : null))
        .filter(idx => idx != null);

      for (let idx of emptyIndices) {
        boardState[idx] = player;
        if (checkWin(player)) {
          boardState[idx] = ' ';
          return idx; // This move leads to a win (or block)
        }
        boardState[idx] = ' ';
      }
      return null;
    }

    // 3. Hard - Minimax
    function getBestMoveMinimax(aiPlayer) {
      // Check for available spots
      const emptyIndices = boardState
        .map((val, idx) => (val === ' ' ? idx : null))
        .filter(idx => idx != null);

      // Check terminal conditions
      if (checkWin('X')) {
        return { score: -10 };
      } else if (checkWin('O')) {
        return { score: 10 };
      } else if (emptyIndices.length === 0) {
        return { score: 0 };
      }

      // Collect possible moves
      const moves = [];

      for (let i = 0; i < emptyIndices.length; i++) {
        const idx = emptyIndices[i];
        // store the current boardState
        const move = {};
        move.index = idx;
        // place the aiPlayer or human player
        boardState[idx] = aiPlayer;

        if (aiPlayer === 'O') {
          // AI's turn
          const result = getBestMoveMinimax('X');
          move.score = result.score;
        } else {
          // Human's turn
          const result = getBestMoveMinimax('O');
          move.score = result.score;
        }

        // revert
        boardState[idx] = ' ';
        moves.push(move);
      }

      // Choose best move
      let bestMove;
      if (aiPlayer === 'O') {
        // maximize
        let bestScore = -Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score > bestScore) {
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      } else {
        // minimize
        let bestScore = Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score < bestScore) {
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      }

      return moves[bestMove];
    }

    /************************************************************
     * BOARD UPDATES & GAME CHECKS
     ************************************************************/

    function updateBoardUI() {
      for (let i = 0; i < 9; i++) {
        const cell = boardEl.children[i];
        cell.textContent = boardState[i] === ' ' ? '' : boardState[i];
        cell.classList.remove('X', 'O');
        if (boardState[i] !== ' ') {
          cell.classList.add(boardState[i]);
        }
      }
    }

    function isBoardFull() {
      return boardState.every(cell => cell !== ' ');
    }

    function checkWin(player) {
      // All winning combos
      const wins = [
        [0,1,2], [3,4,5], [6,7,8], // rows
        [0,3,6], [1,4,7], [2,5,8], // cols
        [0,4,8], [2,4,6]           // diagonals
      ];
      return wins.some(combo => 
        combo.every(index => boardState[index] === player)
      );
    }

    function resetGame() {
      boardState = Array(9).fill(' ');
      currentPlayer = 'X';
      gameOver = false;
      infoEl.textContent = '';
      updateBoardUI();
    }
  </script>
</body>
</html>
